<!DOCTYPE html>
<html lang="en"> 
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Resume - Start Bootstrap Theme</title>
        <link rel="icon" type="image/x-icon" href="assets/img/favicon.ico" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v6.3.0/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />
    </head>
    <body id="page-top">
<!-- Navigation ----------------------------------------------------------------------------------------------------->
        <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
            <a class="navbar-brand js-scroll-trigger" href="#page-top">
                <span class="d-block d-lg-none">Mikayla Lahr</span>
                <span class="d-none d-lg-block"><img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="assets/img/GradPicture.jpg" alt="..." /></span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#home">Home: Mikayla Lahr mrl242</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#Lab 5">Lab 5: Linear PID Control and Linear Interpolation</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#Lab 4">Lab 4: Motors and Open Loop Control</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#Lab 3">Lab 3: TOF</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#Lab 2">Lab 2: IMU</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#Lab 1">Lab 1: The Artemis Board and Bluetooth</a></li>
                </ul>
            </div>
        </nav>
<!-- Page Content -------------------------------------------------------------------------------------------------->
        <div class="container-fluid p-0">
<!-- Home ---------------------------------------------------------------------------------------------------------->
            <section class="resume-section" id="home">
                <div class="resume-section-content">
                    <h1 class="mb-0">
                        Mikayla
                        <span class="text-primary">Lahr</span>
                    </h1>
                    <div class="subheading mb-5">
                        MAE 5190 Fast Robots Lab Reports Spring 2024
                        <a href="mailto:mrl242@cornell.edu">mrl242@cornell.edu</a>
                    </div>
                    <p class="lead mb-5">I am a student in the Department of Mechanical and Aerospace Engineering 
                        at Cornell University. I am interested in robotics. This webpage contains all of the lab 
                        reports for MAE 5190 Fast Robots.
                    </p>
                </div>
            </section>
            <hr class="m-0" />
<!__ Lab 5: Linear PID Control and Linear Interpolation ____________________________________________________________>
            <section class="resume-section" id="Lab 5">
                <div class="resume-section-content">
                    <h2 class="mb-2.5">Lab 5: Linear PID Control and Linear Interpolation</h2>
                    <p>The objective of the lab to to gain experience working with PID controllers.</p>
<!-- Lab 5 Prelab -------------------------------------------------------------------------------------------------->
                    <h2 class="mb-2.5">Prelab</h2>
                    <p>The lab materials include: 
                        <li><a href="https://www.sparkfun.com/products/15443">SparkFun RedBoard Artemis Nano</a></li>
                        <li><a href="https://www.amazon.com/SUMPK-Charging-Braided-Compatible-Samsung/dp/B09Z6J21LY/ref=sr_1_4?keywords=usb%2Bc%2Bto%2Bc&qid=1636380583&qsid=147-6677549-1776715&refinements=p_n_feature_ten_browse-bin%3A23555327011&rnid=23555276011&s=pc&sr=1-4&sres=B08D9SB161%2CB08R68T84N%2CB01CZVEUIE%2CB01FM51812%2CB07VCZV3R4%2CB075V68NVR%2CB075GMKZWW%2CB093BVBRJT%2CB09BBBJ33F%2CB09C2D9Z7T%2CB012V56D2A%2CB092CYFQMP%2CB081L4V3DN%2CB07Y6ZJT1D%2CB07Y2XKPX5%2CB07VPYJV8V%2CB07THJGZ9Z%2CB08W2TP2TT%2CB0744BKDRD%2CB07THFJ1J5&srpt=ELECTRONIC_CABLE&th=1">UCB-C to USB-C Cable</a></li>
                        <li><a href="https://www.mouser.com/ProductDetail/SparkFun/SEN-15335?qs=uwxL4vQweFMcls1MYZT00A%3D%3D">IMU Sensor</a></li>
                        <li><a href="https://www.pololu.com/product/3415">Pololu TOF Distance Sensor</a> ; <a href="https://cdn.sparkfun.com/assets/e/1/8/4/e/VL53L1X_API.pdf">TOF Manual</a> ; <a href="https://cdn.sparkfun.com/assets/8/9/9/a/6/VL53L0X_DS.pdf">TOF Datasheet</a></li>
                        <li><a href="https://www.sparkfun.com/products/18012">QWIIC Breakout Board</a></li>
                        <li><a href="https://www.sparkfun.com/products/14426">QWIIC Connector</a></li>
                        <li><a href="https://www.amazon.com/dp/B07V56N33J?smid=A2ZDGCOOU4F0SF&ref_=chk_typ_imgToDp&th=1">JST2 Connector + Cable</a></li>
                        <li><a href="https://force1rc.com/products/cyclone-remote-control-car-for-kids-adults">Force1 RC Car</li>
                        <li><a href="https://www.amazon.com/URGENEX-Battery-Rechargeable-Quadcopter-Charger/dp/B08T9FB56F/ref=sr_1_3?keywords=lipo+battery+3.7V+850mah&qid=1639066404&sr=8-3">Li-Ion 3.7V 850mAh battery</a></li>
                        <li><a href="https://www.digikey.com/en/products/detail/pololu-corporation/2130/10450426">Dual Motor Drivers</a></li>
                    </p>
                    <h3 class="mb-0">Implement PID Control</h3> <!-------------------------------------------------->
                    <h4 class="mb-0">Send and Recieve Data Over Bluetooth</h4> <!----------------------------------->
<!-- Lab 5 Lab Tasks ----------------------------------------------------------------------------------------------->
                    <h2 class="mb-2.5">Lab Tasks</h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                        <h3 class="mb-0">Position Control</h3> <!--------------------------------------------------->
                        <h3 class="mb-0">Extrapolation</h3> <!------------------------------------------------------>
                        <h3 class="mb-0">5000 Level Task: Wind-Up Protection</h3> <!-------------------------------->
                        </div>
                    </div>
<!-- Lab 5 References ---------------------------------------------------------------------------------------------->
                <h2 class="mb-2.5">Lab 5 References</h2>
                <p>Thank you to all of the TAs that answered my questions. I referenced the past lab reports of 
                    Liam Kain, Rafael Gottlieb, Larry Lu, Julian Prieto, and Ignacio Romo.
                </p>
        </div>
    </section>
<!__________________________________________________________________________________________________________________>
<!__________________________________________________________________________________________________________________>
<!__________________________________________________________________________________________________________________>
<!__________________________________________________________________________________________________________________>
<!__ Lab 4: Motors and Open Loop Control ___________________________________________________________________________>
            <section class="resume-section" id="Lab 4">
                <div class="resume-section-content">
                    <h2 class="mb-2.5">Lab 4: Motors and Open Loop Control</h2>
                        <p>The objective of the lab is to control the car using open loop control, rather than the 
                            manual controller. Two dual motor drivers will be connected to the car's motors and the 
                            Artemis board. The dual motor drivers will be used to control the movement of the car.
                        </p>
<!-- Lab 4 Prelab -------------------------------------------------------------------------------------------------->
                    <h2 class="mb-2.5">Prelab</h2>
                    <p>The prelab involved reading about how to use an oscilloscope and determining how to connect 
                        the dual motor drivers to the motors and Artemis board.
                        The lab materials include: 
                        <li><a href="https://www.sparkfun.com/products/15443">SparkFun RedBoard Artemis Nano</a></li>
                        <li><a href="https://www.amazon.com/SUMPK-Charging-Braided-Compatible-Samsung/dp/B09Z6J21LY/ref=sr_1_4?keywords=usb%2Bc%2Bto%2Bc&qid=1636380583&qsid=147-6677549-1776715&refinements=p_n_feature_ten_browse-bin%3A23555327011&rnid=23555276011&s=pc&sr=1-4&sres=B08D9SB161%2CB08R68T84N%2CB01CZVEUIE%2CB01FM51812%2CB07VCZV3R4%2CB075V68NVR%2CB075GMKZWW%2CB093BVBRJT%2CB09BBBJ33F%2CB09C2D9Z7T%2CB012V56D2A%2CB092CYFQMP%2CB081L4V3DN%2CB07Y6ZJT1D%2CB07Y2XKPX5%2CB07VPYJV8V%2CB07THJGZ9Z%2CB08W2TP2TT%2CB0744BKDRD%2CB07THFJ1J5&srpt=ELECTRONIC_CABLE&th=1">UCB-C to USB-C Cable</a></li>
                        <li><a href="https://www.mouser.com/ProductDetail/SparkFun/SEN-15335?qs=uwxL4vQweFMcls1MYZT00A%3D%3D">IMU Sensor</a></li>
                        <li><a href="https://www.pololu.com/product/3415">Pololu TOF Distance Sensor</a> ; <a href="https://cdn.sparkfun.com/assets/e/1/8/4/e/VL53L1X_API.pdf">TOF Manual</a> ; <a href="https://cdn.sparkfun.com/assets/8/9/9/a/6/VL53L0X_DS.pdf">TOF Datasheet</a></li>
                        <li><a href="https://www.sparkfun.com/products/18012">QWIIC Breakout Board</a></li>
                        <li><a href="https://www.sparkfun.com/products/14426">QWIIC Connector</a></li>
                        <li><a href="https://www.amazon.com/dp/B07V56N33J?smid=A2ZDGCOOU4F0SF&ref_=chk_typ_imgToDp&th=1">JST2 Connector + Cable</a></li>
                        <li><a href="https://force1rc.com/products/cyclone-remote-control-car-for-kids-adults">Force1 RC Car</li>
                        <li><a href="https://www.amazon.com/URGENEX-Battery-Rechargeable-Quadcopter-Charger/dp/B08T9FB56F/ref=sr_1_3?keywords=lipo+battery+3.7V+850mah&qid=1639066404&sr=8-3">Li-Ion 3.7V 850mAh battery</a></li>
                        <li><a href="https://www.digikey.com/en/products/detail/pololu-corporation/2130/10450426">Dual Motor Drivers</a></li>
                    </p>
                    <h3 class="mb-0">Sketch Of Wiring Diagram</h3> <!----------------------------------------------->
                        <p>Below is a wiring diagram for the two dual motor drivers connected to the Artemis board, 
                            DC Motors, and 850mAh battery. The two VIN pins and the two GND pins on both dual motor 
                            drivers are connected together and then connected to the 850mAh battery. The GND pin of 
                            one of the dual motor drivers is connected to the GND of the Artemis board. There is a 
                            bridge between the BOUT1 and AOUT1 pins of the dual motor driver that is then connected 
                            to the DC motor. There is also a bridge between the BOUT2 and AOUT2 pins of the dual motor 
                            driver that is then connected to the DC motor. There is a bridge between the BIN1 and AIN1 
                            pins on the dual motor driver and there is also a bridge between the BIN2 and AIN2 pins. 
                            On the dual motor driver that connects the drivers to the ground of the Artemis board (top 
                            dual motar driver in sketch below), the bridge between BIN1 and AIN1 is connected to pin 11, 
                            and the bridge between BIN2 and AIN2 is connected to pin 12. On the other dual motor driver 
                            (bottom dual motor driver in sketch below) the bridge between BIN1 and AIN1 is connected 
                            to pin 7, and the bridge between BIN2 and AIN2 is connected to pin 9. The pins used in this 
                            lab were chosen from the remaining pins on the Artemis board (after the previous lab). The 
                            parallel-couple of the two inputs and two outputs on each dual motor driver allows for 
                            twice the average current to be delivered without overheating.
                        </p>
                    <img width="550" height="auto" src="Lab4/DualMotorDriverWiring.png"></img>
                    <h3 class="mb-0">Battery Discussion</h3> <!----------------------------------------------------->
                        <p>The Artemis board and the motor drivers/motors are powered from separate batteries. The 
                            Artemis board is powered using a 650mAh battery and the motors are powered using a 850mAh 
                            battery. Having the Artemis board and motors powered by different power sources avoids 
                            any potential transient effects and allows each component to function independently. Any
                            potential current changes in the motors will not affect the Artemis board. In addition, 
                            the motors require a higher current battery, which is the reason the 850mAh battery is 
                            used to power the motors.
                        </p>
<!-- Lab 4 Lab Tasks ----------------------------------------------------------------------------------------------->
                    <h2 class="mb-2.5">Lab Tasks</h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                        <h3 class="mb-0">Testing The Circuit With The Oscilloscope and Power Supply</h3> <!--------->
                        <h4 class="mb-0">Picture Of Setup With Power Supply and Oscilloscope Hookup</h4> <!--------->
                            <p>The below image is a picture of the power supply and oscilloscope connections. The 
                                positive power supply wire (red, towards the top of the picture) is connected to the 
                                positive wire of the battery. The ground wire of the power supply (black) and 
                                oscilloscope (black) is connected to the same ground wire of the battery (near the 
                                middle of the picture). The input for the oscilloscope (near the bottom of the 
                                picture) is connected to the wire that will be attached to one of the motors. Each of 
                                the four wires that will be attached to the motors was tested to determine if the 
                                circuit was assembled correctly and a PWM signal was shown on the oscilloscope.
                            </p>
                            <img width="550" height="auto" src="Lab4/OscilloscopeAttachedWires.png"></img>
                            <p>Picture of oscilloscope (left) and power supply (right) connected to the circuit:</p>
                            <img width="550" height="auto" src="Lab4/FullOscilloscopePicture.png"></img>
                        <h4 class="mb-0">Power Supply Setting And Oscilloscope Discussion</h4> <!--------------------->
                            <p>The voltage of the 850mAh battery is 3.7V. In place of using the battery, a power supply 
                                was used. The output of the power supply was set to 3.7V to represent the battery 
                                power that will be used later on during the lab. Each pin was tested independently of 
                                each other. In the Arduino IDE code, one pin was set to have an output of 200, while 
                                the other pins all had an output of 0. This was repeated for all four pins. The positive 
                                output voltage to the motor was displayed on the oscilloscope and indicated a constant 
                                voltage output at each time. The PWM values show that power can be regulated on the motor 
                                driver output.
                            </p>
                            <p>Channel 3 of the power supply was used. 3.7V was used to test the motor driver circuit.</p>
                            <img width="550" height="auto" src="Lab4/PowerSupply.png"></img>
                            <p>Picture of the oscilloscope output:</p>
                            <img width="550" height="auto" src="Lab4/OscilloscopeMonitor.png"></img>
                            <p>The below four videos show the output for each pin that was tested (pins 7, 9, 11, 12):</p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/lCriKyb0Neg"></iframe>
                            <iframe width="550" height="400" src="https://youtube.com/embed/N995RlmhQh0"></iframe>
                            <iframe width="550" height="400" src="https://youtube.com/embed/0vjtACvWswE"></iframe>
                            <iframe width="550" height="400" src="https://youtube.com/embed/TmjGBAryqm0"></iframe>
                        <h4 class="mb-0">Motor Driver Code Snippet Using analogWrite</h4> <!------------------------>
                            <p>The below Arduino code shows how each of the wires to the motors were tested. Pins 7, 
                                9, 11, and 12 were defined and analogWrite() was used to assign each pin number the 
                                tested output value. In the below example pin 11 is set to have an output of 200, and
                                all of the other pins have an output of 0.
                            </p>
                            <img width="200" height="auto" src="Lab4/PowerSupplyCode.png"></img>
                        <h3 class="mb-0">Testing The Robot Wheels</h3> <!------------------------------------------->
                        <h4 class="mb-0">Video Of Wheels Spinning (Each Side Of Robot)</h4> <!---------------------->
                            <p>The wheels on each side of the robot were tested individually at two different output 
                                values. The power supply used at the beginning of the lab (3.7V) was used to power 
                                the motors. Pins 7, 9, 11, and 12 were tested at output values of  50 and 200. While 
                                testing each side of the robot I observed the direction and speed that each wheel 
                                turned. The wheels rotated faster for the higher output at 200 compared to the output 
                                at 50. For the higher output value of 200, the wheels reached the final set speed faster 
                                compared to the lower set speed. When rotating at 50 the wheels took longer to start rotating.
                                From the perspective of the videos pin 7 rotates counter clockwise and pin 9 
                                rotates clockwise. Pin 7 and pin 9 move the wheels on the same side of the robot in 
                                different directions. In addition, from the perspective of the videos pin 11 moves 
                                clockwise and pin 12 moves counter clockwise. Pin 11 and pin 12 move the wheels on 
                                the same side of the robot in different directions. To consolidate the report, all 
                                of the videos taken can be found in this folder: <a href="https://drive.google.com/drive/folders/1C0Mv_Gn857_GPnvRFywwlARlJ5vl_ICM?usp=sharing">Folder Link</a>
                                Below are videos of pin 12 and pin 9 with an output value of 200. 
                            </p>
                            <p>Pin 12 with an output of 200:</p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/NtxG2B53yNE"></iframe>
                            <p>Pin 9 with an output of 200:</p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/vF0gQiVKP0E"></iframe>
                            <p>The Arduino code to test the wheels is found below. One pin was set to have an output 
                                value of either 50 or 200 and all other pins were set to have an output value of 0.
                                This is the same code that was used in the previous section to test if the circuit 
                                was working properly before sautering to the motors.
                            </p>
                            <img width="200" height="auto" src="Lab4/OneSideWheelsSpinning.png"></img>
                        <h4 class="mb-0">Video Of All Wheels Spinning</h4> <!--------------------------------------->
                            <p>After testing each side of the robot, all of the wheels were tested at the same time. 
                                The 850mAh battery was used to power the motors instead of the power supply. The below 
                                video shows both sides rotating while the motors and Artemis board are both connected
                                to their respective batteries.
                            </p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/riR7c_fM4ns"></iframe>
                            <p>The Arduino code to test the wheels on both sides of the robot is found below. Pins 9 
                                and 12 were set to have an output of 200 and pins 7 and 11 were set to have an output 
                                value of 0. This is the same code that was used in the previous section to test both 
                                sides of the robot individually.
                            </p>
                            <img width="200" height="auto" src="Lab4/WheelsSpinning.png"></img>
                        <h4 class="mb-0">Picture Of All Components On Car</h4> <!----------------------------------->
                            <p>Below is a labeled picture showing all components on the robot. Including the 650mAh 
                                battery, Artemis board, IMU, two ToF sensors, two motor drivers, and a breakout board.
                                The 850mAh battery to power the motors is on the other side of the robot. 
                            </p>
                            <img width="550" height="auto" src="Lab4/RobotDiagram.png"></img>
                            <p>After connecting all components to the car I decided to test how the robot moves. The 
                                video below shows my first test for having the robot drive on the ground. In the video, 
                                the robot initially moves towards the left when the pins used for the motors have the 
                                same output value. This trend was noticed in future steps of the lab when determining 
                                how to calibrate each of the motors.
                            </p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/IpvEgT9b_50"></iframe>
                            <p>The below code shows the loop used to run the robot on the ground.</p>
                            <img width="200" height="auto" src="Lab4/NonCal1.png"></img>
                            <img width="200" height="auto" src="Lab4/NonCal2.png"></img>
                            <p>Below is a diagram of the entire wiring that is used on the robot:</p>
                            <img width="600" height="auto" src="Lab4/CompleteWiring.png"></img>
                        <h3 class="mb-0">Lower Limit PWM And Open Loop Control</h3> <!------------------------------>
                        <h4 class="mb-0">Lower Limit PWM Value Discussion</h4> <!----------------------------------->
                            <p>During this step of the lab, I used Bluetooth to send a command from Jupyter Notebook 
                                to run different output values more easily compared to uploading Arduino IDE code every
                                time I wanted to change the output value of a pin. The below images show the Jupyter
                                Notebook Command and the Arduino IDE case that uses analogWrite() to move the robot. 
                            </p>
                            <img width="650" height="auto" src="Lab4/PythonCMD.png"></img>
                            <img width="550" height="auto" src="Lab4/ArduinoSLCase1.png"></img>
                            <img width="550" height="auto" src="Lab4/ArduinoSLCase2.png"></img>
                            <p>The lower limit PWM value is the lowest output value that a pin can be set to that will 
                                still result in continuous motion of the robot. The wheels on one side of the robot 
                                were tested, while the wheels on the other side remained stationary. The lower limit 
                                PWM for pin 11 (right side) was found to be 59. The lower limit PWM for pin 7 (left
                                side) was found to be 50. 
                            </p>                       
                            <p>Note: During lab office hours I asked a TA (Larry Lu) about how the surface conditions 
                                affect the PWM values. Specifically I asked if testing the robot on the floors in my 
                                apartment (laminate wood flooring) would change the lower limit PWM value compared to 
                                the tile floors in the lab and hallways. I tested the robot's lower limit PWM value at 
                                my apartment and received the same PWM values. The PWM values may start to differ if 
                                the robot is travelling over a surface with a lot of friction such as a carpet or 
                                outside in the grass. This information is helpful to know as I can better understand 
                                the operating conditions of the robot.
                            </p>
                            <p>Pin 11 (Right Wheels) with an output of 59:</p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/j5dqoIw6FOU"></iframe>
                            <p>Pin 7 (Left Wheels) with an output of 50:</p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/ZOekIthGxmg"></iframe>
                            <p>I also found the PWM value for both wheels when they are being used together, starting 
                                when the robot is stationary. The output value was found to be 35 for both wheel sides. 
                                The video showing the robot moving when both wheels (pins 11 and 7) have an output 
                                value of 35.
                            </p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/bWIED69jH9o"></iframe>  
                            <p>Note: During lab office hours I asked a TA (Larry Lu) about how the surface conditions 
                                affect the PWM values. Specifically I asked if testing the robot on the floors in my 
                                apartment (laminate wood flooring) would change the lower limit PWM value compared to 
                                the tile floors in the lab and hallways. I tested the robot's lower limit PWM value at 
                                my apartment and received the same PWM values. The PWM values may start to differ if 
                                the robot is travelling over a surface with a lot of friction such as a carpet or 
                                outside in the grass. This information is helpful to know as I can better understand 
                                the operating conditions of the robot.
                            </p>
                        <h4 class="mb-0">Calibration Demonstration</h4> <!------------------------------------------>
                            <p>The wheels of the robot do not spin at the same rate and a calibration factor needed 
                                to be implemented. The below video shows the robot moving in a straight line, starting
                                at 7 feet and then continuing past the end of the tape measure. For the demonstration,
                                pin 11 was set to an output of 60 and pin 7 was set to an output of 70. In addition to 
                                the below video, the robot was run multiple times at varying input values. My first 
                                tested value was pin 11 at an output of 60, which is close to the found PWM value from 
                                the previous step. When pin 7 was set to an output of 51, the robot continuously moved 
                                towards the left. Through trial and error I found that an output of 70 for pin 7 kept 
                                the robot moving in a straight line. I used these found values for reference during 
                                future tests: 70/60=1.166666666666667. 
                            </p>
                            <p>I increased the output of pin 11 by 20 for each 
                                test and multiplied the value for pin 7 by 1.166666666666667. This incrementation worked 
                                for all tested pin 11 and pin 7 values until I reached an output value of 220 for pin 11. 
                                The calculated output value for pin 7 should be 257, rounded down to 255 due to 255 being
                                the maximum output value. For this test the robot continuously moved towards the right 
                                and the value for pin 7 needed to be lowered to 250 to keep the robot moving straight. 
                                Due to this discovery, I decided to also test an output value of 210 for pin 11, the 
                                calculated output value for pin 7 should be 245. In order to keep the robot moving 
                                straight, and not to the right I needed to reduce the output of pin 7 to 240. The trend 
                                shows that after an output of 200 for pin 11 the calibration factor to find the 
                                corresponding output value for pin 7 starts to differ. 
                            </p>
                            <p>In addition, as a final test I 
                                wanted to determine how low I could set the output values while still having the robot 
                                move in a straight line for at least 6 feet. I set the output value of pin 11 to 40 and 
                                calculated the output value of pin 7 to be 47. For these output values, the robot moved 
                                in a straight line for more than 6 feet. When I set the output value for pin 11 to be 
                                lower than 40 the wheels began to stall and hesitate before rotating compared to the other 
                                side of the robot. I also included a video at the end of the section showing the wheels 
                                spinning.
                            </p>
                            <p>To produce the robots motion the same Arduino IDE case and Jupyter Notebook command were 
                                used. The length of the delay was changed depending on how fast the robot moved (to prevent 
                                the robot from running into a wall). All of the recorded videos are in <a href="https://drive.google.com/drive/folders/1MPB9ob9C-Wnmy3WKEV63vXBIjMhBrcxV?usp=drive_link">this folder.</a>
                            </p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/up1g-nOJNPY"></iframe>
                            <p>Below is a graph showing all of the tested values as data points. In addition, I plotted the 
                                trendline for all data points, as well as the trendline for all of the data points except 
                                for the last two that began to differ from the previous measurements. The slope and 
                                y-intercept were also found for each trendline. The calculated slope is the calibration 
                                factor. The slope excluding the last two data points, 1.165 is close to the 1.166666666666667
                                value.
                            </p>
                            <img width="550" height="auto" src="Lab4/NewStraightLineGraph.png"></img>
                            <p>Video showing wheels hesitating when pin 11 (right) has an output of 35 and pin 7 (left)
                                has an output of 41:
                            </p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/T0syacfa-Sk"></iframe>
                            <p>I also tested the calibration factor when the robot is going in "reverse" (with the robot 
                                moving in the direction away from the ToF sensor on one end). I initially tested the 
                                previously found output values with the corresponding pins on each wheel side, with pin 12 
                                having an output of 60 and pin 9 having an output of 70. I found that by doing this the 
                                robot moved towards the left. I decided to switch the output values; pin 12 has an output 
                                of 70 and pin 9 has an output of 60). The robot moves straight using these output values. 
                                I find this interesting as it confirm my previous thoughts about one side of the wheels 
                                being slightly misaligned. 
                            </p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/KikE52expXI"></iframe>
                        <h4 class="mb-0">Open Loop Code And Video</h4> <!------------------------------------------->
                            <p>Below is a video showing open loop control of the robot. In the video the robot moves 
                                forward, turn towards the right, moves backward, stops, spins counterclockwise, stops,
                                spins clockwise, and then stops. I used output values found from the calibration graph.
                            </p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/OKhd_hvgN-8"></iframe>
                            <p>Arduino code for robot motion:</p>
                            <img width="200" height="auto" src="Lab4/OpenLoopControl1.png"></img>
                            <img width="200" height="auto" src="Lab4/OpenLoopControl2.png"></img>
                        <h3 class="mb-0">5000 Level Tasks:</h3> <!-------------------------------------------------->
                        <h4 class="mb-0">analogWrite Frequency Discussion</h4> <!----------------------------------->
                            <p>Below is the image of the oscilloscope when connected to the circuit. The wheel motors 
                                are powered using the battery. During lab office hours I asked a TA why the oscilloscope 
                                outputs were ore noisy compared to the oscilloscope outputs from earlier in the lab and 
                                it is most likely because the circuit is now connected to the motors that result in more 
                                noise compared to when the circuit was not connected to the motors on the robot.
                            </p>
                            <img width="550" height="auto" src="Lab4/analogWrite5000.png"></img>
                            <p>From the image its can be seen that one horizontal block along the x-axis is 2.50ms and 
                                one vertical block along the y-axis is 1.0V. The period of the PWM signal is about 2.6 
                                horizontal blocks, which is equivalent to 6.50ms (0.0065s). The frequency analogWrite() 
                                generates is about 1/0.0065s ~= 154Hz. In lab 3 the sampling period of the ToF sensors
                                was found to be 0.04s and the sampling frequency was 25Hz. The frequency analogWrite() 
                                generates is fast enough for the motors on the robot when running tests as well as when 
                                using data from the ToF sensors. Manually configuring the timers to generate a faster PWM
                                signal will allow for more control over the movements of the robot and a more steady PWM 
                                signal.
                            </p>
                            <p>The code used during the oscilloscope observation is below:</p>
                            <img width="200" height="auto" src="Lab4/WheelsSpinningNew.png"></img>
                        <h4 class="mb-0">Lowest PWM Value Speed Discussion</h4> <!---------------------------------->
                            <p>The lowest PWM value for each side of the robot was found by running the robot with an 
                                initial output of 60 for pin 11 and 70 for pin 7 to correspond with the found 
                                calibration values. The robot ran with these outputs for 3 seconds and then all pin 
                                outputs were set to zero expect either pin 11 or pin 7. Either pin 11 or pin 7 remained 
                                turned on for another 3 seconds, but decreased to a lower output value. I ran the robot 
                                multiple times to determine at what output value the robot no longer moved. It was 
                                determined that for pin 11 the lowest PWM output is 35 and for pin 7 the lowest PWM 
                                output is 33. The videos for each pin can be found below.
                            </p>
                            <p>Pin 11 with a lowest PWM value of 35:</p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/GVot4WoKJfg"></iframe>
                            <p>Pin 7 with a lowest PWM value of 33:</p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/y8LbCTM5KOg"></iframe>
                            <p>In addition, the lowest combined wheel PWM value was found when both wheels were being 
                                used at the same time. The output value for both wheels (pin 11 and pin 7) is 25 when 
                                the robot is already moving. The robot was initially run with an initial output of 60 
                                for pin 11 and 70 for pin 7 for 1.5 seconds and then both wheels decreased to an output 
                                of 25 for 5 seconds. Below are two videos. One video shows the final output at 25 (the 
                                robot moves until the total set time of 5 seconds is over). The other video shows the 
                                robot stop before the 5 seconds is over and the motors stall when set to an output of 
                                24, confirming the lower limit PWM value of 25 to keep the robot moving.
                            <p>Both Wheels: Lower Limit PWM of 25:</p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/Qsuw1Hp_cbg"></iframe>
                            <p>Both Wheels: Tested value of 24:</p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/8UgnAjQbpKM"></iframe>
                            <p>The command line in Jupyter Notebook and the Arduino IDE case can be found below:</p>
                            <img width="650" height="auto" src="Lab4/PWMContinuousPython.png"></img>
                            <img width="550" height="auto" src="Lab4/PWMContinuousArduino1.png"></img>
                            <img width="550" height="auto" src="Lab4/PWMContinuousArduino2.png"></img>                            
                        </div>
                    </div>
<!-- Lab 4 References ---------------------------------------------------------------------------------------------->
                <h2 class="mb-2.5">Lab 4 References</h2>
                <p>Thank you to all of the TAs that answered my questions. I referenced the past lab reports of 
                    Liam Kain, Rafael Gottlieb, Larry Lu, Julian Prieto, and Ignacio Romo.
                </p>
        </div>
    </section>
<!__________________________________________________________________________________________________________________>
<!__________________________________________________________________________________________________________________>
<!__________________________________________________________________________________________________________________>
<!__________________________________________________________________________________________________________________>
<!__ Lab 3: TOF ____________________________________________________________________________________________________>
            <section class="resume-section" id="Lab 3">
                <div class="resume-section-content">
                    <h2 class="mb-2.5">Lab 3: TOF</h2>
                    <p>The objective of the lab is to connect the time of flight (TOF) sensors to the Artemis board. 
                    </p>
<!-- Lab 3 Prelab -------------------------------------------------------------------------------------------------->
                    <h2 class="mb-2.5">Prelab</h2>
                    <p>The prelab involved reading about the ToF sensor used in the lab. The lab materials include: 
                        <li><a href="https://www.sparkfun.com/products/15443">SparkFun RedBoard Artemis Nano</a></li>
                        <li><a href="https://www.amazon.com/SUMPK-Charging-Braided-Compatible-Samsung/dp/B09Z6J21LY/ref=sr_1_4?keywords=usb%2Bc%2Bto%2Bc&qid=1636380583&qsid=147-6677549-1776715&refinements=p_n_feature_ten_browse-bin%3A23555327011&rnid=23555276011&s=pc&sr=1-4&sres=B08D9SB161%2CB08R68T84N%2CB01CZVEUIE%2CB01FM51812%2CB07VCZV3R4%2CB075V68NVR%2CB075GMKZWW%2CB093BVBRJT%2CB09BBBJ33F%2CB09C2D9Z7T%2CB012V56D2A%2CB092CYFQMP%2CB081L4V3DN%2CB07Y6ZJT1D%2CB07Y2XKPX5%2CB07VPYJV8V%2CB07THJGZ9Z%2CB08W2TP2TT%2CB0744BKDRD%2CB07THFJ1J5&srpt=ELECTRONIC_CABLE&th=1">UCB-C to USB-C Cable</a></li>
                        <li><a href="https://www.pololu.com/product/3415">Pololu TOF Distance Sensor</a> ; <a href="https://cdn.sparkfun.com/assets/e/1/8/4/e/VL53L1X_API.pdf">TOF Manual</a> ; <a href="https://cdn.sparkfun.com/assets/8/9/9/a/6/VL53L0X_DS.pdf">TOF Datasheet</a></li>
                        <li><a href="https://www.sparkfun.com/products/18012">QWIIC Breakout Board</a></li>
                        <li><a href="https://www.sparkfun.com/products/14426">QWIIC Connector</a></li>
                    </p>
                    <h3 class="mb-0">Task 1: Note The I2C Sensor Address</h3> <!------------------------------------>
                        <p>From the datasheet it was found that the I2C sensor address for the ToF sensor is 0x52. 
                            The two ToF sensors have the same address and one of the addresses will need to be changed 
                            in order to receive data from both sensors at the same time. 
                        </p>
                    <h3 class="mb-0">Task 2: Approach To Using Two ToF Sensors</h3> <!------------------------------>
                        <p>To use two ToF sensors, the XSHUT pin will be used to connect one of the ToF sensors to pin 
                            8 on the Artemis board. The XSHUT pin will be set to LOW and then the I2C sensor address 
                            will be changed for the other ToF sensor that is on. After the I2C address has been changed 
                            the XSHUT pin will be set to HIGH, turning the other TOF sensor back on. This will allow for 
                            both ToF sensors to be used in parallel. 
                        </p>
                    <h3 class="mb-0">Task 3: Placement Of Sensors On Robot</h3> <!---------------------------------->
                        <p>The placement of the two ToF sensors on the robot will impact the field of vision. Two 
                            long QWIIC connectors will be used to attach the ToF sensors. Longer connectors will allow 
                            me to position the ToF sensors in more potential ways compared to shorter wires. The 
                            potential arrangements of the sensors include (1) a sensor on the front and left side, 
                            (2) a sensor on the front and right side, (3) two sensors positioned on either side of 
                            the front of the robot, and (4) a sensor on the front and the back. Depending on the task 
                            at hand any of these sensor positions may be effective. 
                            If there is no sensor on the back of the robot there might be an issue if the robot needs 
                            to back up or move in reverse. If there is no sensor on the side then the robot might miss 
                            an obstacle that is located in a blind spot. 
                        </p>
                    <h3 class="mb-0">Task 4: Sketch Of Wiring Diagram</h3> <!--------------------------------------->
                        <img width="550" height="auto" src="Lab3/Lab3WireDiagram.jpg"></img>
<!-- Lab 3 Lab Tasks ----------------------------------------------------------------------------------------------->
                    <h2 class="mb-2.5">Lab Tasks</h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                        <h3 class="mb-0">Task 1: ToF Sensor Connected To QWIIC Breakout Board</h3> <!--------------->
                            <p>The Artemis board was powered using a battery:
                            </p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/DU1Uwm4gzos"></iframe>
                            <p>ToF sensors connected to the QWIIC breakout board:</p>
                            <img width="550" height="auto" src="Lab3/Lab3Setup.jpeg"></img>
                            <hr>
                            <img width="400" height="auto" src="Lab3/Lab3ToF1.jpeg"></img>
                            <hr>
                            <img width="400" height="auto" src="Lab3/Lab3Tof2.jpeg"></img>
                        <h3 class="mb-0">Task 2: Artemis Scanning For I2C Device</h3> <!---------------------------->
                            <p>The SparkFun VL53L1X 4m Laser Distance Sensor Library was installed on Arduino IDE.
                                The code to find the I2C address: File->Examples->Apollo3->Wire->Example05_Wire_I2C.ino
                            </p>
                            <img width="550" height="auto" src="Lab3/Lab3I2C.png"></img>
                            <p>One ToF sensor was connected during the scan. The sensor had an I2C address of 0x29. 
                                In the datasheet for the ToF sensor, the listed I2C address is 0x52. The 
                                Example05_Wire_I2C.ino code returned an address of 0x29. This is a result of the 
                                binary for address 0x52 (binary: 0b01010010) being shifted to the right, resulting in 
                                an address of 0x29 (binary: 0b00101001). The rightmost bit is ignored because the bit 
                                identifies if data is read/write.
                            </p>
                        <h3 class="mb-0">Task 3: Sensor Data With Chosen Mode</h3> <!------------------------------->
                            <h4 class="mb-0">Sensor Mode Discussion</h4> <!----------------------------------------->
                            <p>The ToF sensor has two modes: (.setDistanceModeMedium(); //3m has been removed)
                                <li>.setDistanceModeShort(); //1.3m</li>
                                <li>.setDistanceModeLong(); //4m</li>
                            </p>
                            <p>Information from the datasheet shows 
                                that the short mode can only reach up to 1.3m and is the most resistant to ambient 
                                light. The long mode can reach up to 4m but is very sensitive to ambient light, which 
                                decreases the distance to 0.73m. The timing budget range for the short mode is 20ms - 
                                1000ms. The timing range for the long mode is 33ms - 1000ms. Short mode has greater 
                                accuracy and less sensor noise compared to the long mode. While it would be beneficial 
                                for a robot that needs to sense objects farther away to use the long mode, for this lab 
                                I am prioritizing accuracy and choose to test the short mode. 
                            </p>
                            <h4 class="mb-0">Testing .setDistanceModeShort();</h4> <!------------------------------->
                            <p>The ToF sensor was first tested using the 
                                File->Examples->SparkFun_VL53L1X_4m_Laser_Distance_Sensor->Example1_ReadDistance.ino
                                This code was modified to include the line 
                                distanceSensor.setDistanceModeShort(); in the setup to choose the short mode for the 
                                ToF sensor.
                            </p>
                            <p>ToF Sensor Setup: 
                            </p>
                            <img width="500" height="auto" src="Lab3/Lab3DistanceSetup1.jpeg"></img>
                            <img width="500" height="auto" src="Lab3/Lab3DistanceSetup2.png"></img>
                            <hr>
                            <p>Arudino code to find the ToF distance: 
                            </p>
                            <img width="650" height="auto" src="Lab3/Lab3DistanceArduino.png"></img>
                            <img width="550" height="auto" src="Lab3/DistanceJupyter.png"></img>
                            <hr>
                            <p>Sensor Range:</p>
                            <p>In the datasheet it is stated that the short mode for the ToF sensor has a range up to 1.3m.
                                To test the range of the sensor I took an initial measurement at 100mm and continued to take 
                                measurements up to 1900mm. The graph below shows the actual distance of the ToF sensor from 
                                the wall vs the ToF sensor distance.
                                The plotted measured distance value is the mean value of the ten collected data 
                                points. From the graph below it can be seen that after 1.3m the measured values start to 
                                differ more from the actual values compared to measured values less than 1.3m. 
                            </p>
                            <img width="550" height="auto" src="Lab3/Lab3MeasuredvsActual.png"></img>
                            <hr>
                            <p>Accuracy:</p>
                            <p>The difference in the measured and actual distances was plotted against the actual distances the 
                                ToF sensor was from the wall. When the ToF sensor is less than 1.3m from the wall, the difference 
                                is between 18mm and 40mm. After 1.3m the difference in the measured vs actual distance increases. 
                            </p>
                            <img width="550" height="auto" src="Lab3/Lab3DiffvsActual.png"></img>
                            <hr>
                            <p>Repeatability:</p>
                            <p>The standard deviation vs actual distance graph is shown below. The standard deviation is below 3mm 
                                for measurements under 1.3m. After 1.3m the standard deviation starts to vary and the standard 
                                deviation at 1900mm is 8.75mm.
                            </p>
                            <img width="550" height="auto" src="Lab3/Lab3SDvsActual.png"></img>
                            <p>Below are the time and measured distance arrays:</p>
                            <p>100mm: 9 measurements at 75mm, 1 measurement at 74mm</p>
                            <img width="550" height="auto" src="Lab3/D100mm.png"></img>
                            <hr>
                            <p>300mm: 6 measurements at 268mm, 4 measurements at 267mm</p>
                            <img width="550" height="auto" src="Lab3/D300mm.png"></img>
                            <hr>
                            <p>500mm: 5 measurements at 478mm, 5 measurements at 479mm</p>
                            <img width="550" height="auto" src="Lab3/D500mm.png"></img>
                            <hr>
                            <p>700mm: 5 measurements at 679mm, 4 measurements at 681mm, 1 measurement at 677mm</p>
                            <img width="550" height="auto" src="Lab3/D700mm.png"></img>
                            <hr>
                            <p>900mm: 4 measurements at 882mm, 5 measurements at 879mm, 1 measurement at 883mm</p>
                            <img width="550" height="auto" src="Lab3/D900mm.png"></img>
                            <hr>
                            <p>1100mm: 5 measurements at 1076mm, 4 measurements at 1070mm, 1 measurement at 1071mm</p>
                            <img width="550" height="auto" src="Lab3/D1100mm.png"></img>
                            <hr>
                            <p>1300mm: 4 measurements at 1258mm, 4 measurements at 1263mm, 2 measurements at 1265mm</p>
                            <img width="550" height="auto" src="Lab3/D1300mm.png"></img>
                            <hr>
                            <p>1500mm: 3 measurements at 1448mm, 2 measurements at 1447mm, 3 measurements at 1440mm, 2 measurements at 1449mm</p>
                            <img width="550" height="auto" src="Lab3/D1500mm.png"></img>
                            <hr>
                            <p>1700mm: 2 measurements at 1634mm, 3 measurements at 1631mm, 3 measurements at 1632mm, 2 measurements at 1637mm</p>
                            <img width="550" height="auto" src="Lab3/D1700mm.png"></img>
                            <hr>
                            <p>1900mm: 3 measurements at 1782mm, 2 measurements at 1791mm, 4 measurements at 1802mm, 1 measurement at 1784mm</p>
                            <img width="550" height="auto" src="Lab3/D1900mm.png"></img>
                            <hr>
                            <p>Ranging Time:</p>
                            <p>The ranging time is the time between each sensor measurement. I commented out all print 
                                statements, except the calculated value between the start and end times to allow for 
                                code to run as fast as possible. The ranging time was found to be around 55ms. 
                            </p>
                            <img width="400" height="auto" src="Lab3/Lab3RangingTime.png"></img>
                            <hr>
                        <h3 class="mb-0">Task 4: Two ToF Sensors: Working In Parallel</h3> <!----------------------->
                            <p>Two ToF Sensors were connected to the Artemis board and Arduino code needed to be 
                                written for the two ToF sensors to work in parallel. The code below is written 
                                according to the prelab procedure. 
                            </p>
                            <img width="550" height="auto" src="Lab3/2TOFCode.png"></img>
                            <p>The Serial Monitor prints the I2C addresses for both distance sensors to confirm 
                                that one of the addresses was changed to 0x30 and the other remains 0x52. 
                            </p>
                            <img width="450" height="auto" src="Lab3/2TOFDistanceSerial.png"></img>
                            <hr>
                            <iframe width="550" height="400" src="https://youtube.com/embed/g8wL6XBF1ZU"></iframe>
                        <h3 class="mb-0">Task 5: ToF Sensor Speed: Speed And Limiting Factor</h3> <!---------------->
                            <p>The code to find the ToF sensor speed can be found below. Time is continuously printed 
                                and distance measurements are only printed when a measurement is available. 
                            </p>
                            <img width="550" height="auto" src="Lab3/TimeDistanceCode.png"></img>
                            <p>When the 
                                sensors are not collecting data the loop takes around 2ms. When data is being collected 
                                the loop takes around 11ms. The longer loop time when collecting ToF sensor data is 
                                the limiting factor. The limiting factor is the time needed to record distance 
                                measurements.
                            </p>
                            <img width="400" height="auto" src="Lab3/TimeDistanceSerial.png"></img>
                            <hr>
                            <iframe width="550" height="400" src="https://youtube.com/embed/8FiNLwD_AbY"></iframe>
                        <h3 class="mb-0">Task 6: Time vs Distance: Data From Two ToF Sensors Over Bluetooth</h3> <!->
                            <p>The code from Lab 2 was modified to send time stamped ToF sensor data to Jupyter 
                                Notebook. The data for the two ToF sensors was plotted against the recorded time. The 
                                case I created in Arduino can be found below. 
                            </p>
                            <img width="650" height="auto" src="Lab3/Lab3ToFBluetoothCode.png"></img>
                            <hr>
                            <img width="550" height="auto" src="Lab3/Lab3ToFTimeGraph2.png"></img>
                            <hr>
                            <img width="550" height="auto" src="Lab3/Lab3TwoSensorsArray.png"></img>
                        <h3 class="mb-0">5000 Level Task 1: Discuss Different Distance Infrared Sensors</h3> <!----->
                            <h4 class="mb-0">Active and Passive Infrared Sensors</h4>
                            <p>The two main types of infrared sensors are active and passive infrared sensors. Passive 
                                infrared sensors sense nearby emitted infrared light, using a difference in signals 
                                between two pyroelectric sensors. These sensors are often used for security 
                                purposes to detect if there is a heat energy change in the environment, but cannot 
                                determine the distance to an object.
                                Active infrared sensors use an emitter and receiver to determine the distance
                                to an object.  
                                If there is an obstruction, the active infrared sensor knows that there is an object 
                                in between the emitter and receiver. Active infrared sensors are used in industry 
                                conveyor belts, as well as in garage door safety mechanisms. 
                                <a href="https://www.arrow.com/en/research-and-events/articles/understanding-active-and-passive-infrared-sensors">(Source: Arrow Electronics)</a>
                                Different types of infrared sensors include proximity sensors, ToF sensors, and triangulation sensors.
                                <a href="https://itp.nyu.edu/physcomp/distance-sensors-the-basics/#:~:text=Infrared%20LED%20Proximity%20Sensors,'%20rather%20than%20'distance'.">(Source: NYU)</a>
                            </p>
                        <h3 class="mb-0">5000 Level Task 2: ToF Response To Different Colors And Textures</h3> <!--->
                            <p>Four colors and three textures were tested at a distance of 500mm. Colors include pink, 
                                blue, yellow, and red. Textures include a hand towel, rug, and folder. The control 
                                surface was the dark grey wall that I used throughout the lab for distance readings.
                                The change in color or texture did not affect the ToF sensor's distance output that 
                                remained around 478mm.
                            </p>
                            <p>Control:</p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/X29VpoKLW5k"></iframe>
                            <hr>
                            <p>Color Pink:</p>
                            <iframe width="550" height="400" src="https://drive.google.com/file/d/1PUoaYNY344HtOt2QB5BEjrhq8XYqkNpa/preview"></iframe>
                            <hr>
                            <p>Color Blue:</p>
                            <iframe width="550" height="400" src="https://drive.google.com/file/d/1jj8VRlJxJkV5Udfwd45NXSNasH43Xe9T/preview"></iframe>
                            <hr>
                            <p>Color Yellow:</p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/TF_1-f9MVUo"></iframe>
                            <hr>
                            <p>Color Red:</p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/IE-Uqex8R2I"></iframe>
                            <hr>
                            <p>Texture Hand Towel:</p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/FFUvzX8Frlc"></iframe>
                            <hr>
                            <p>Texture Rug:</p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/rp7Hfwz03OA"></iframe>
                            <hr>
                            <p>Texture Folder:</p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/s5__EZTu5o8"></iframe>
                        </div>
                    </div>
<!-- Lab 3 References ---------------------------------------------------------------------------------------------->
                <h2 class="mb-2.5">Lab 3 References</h2>
                <p>Thank you to all of the TAs that answered my questions. I referenced the past lab reports of 
                    Liam Kain, Rafael Gottlieb, Larry Lu, Julian Prieto, and Ignacio Romo.
                </p>
        </div>
    </section>
<!__________________________________________________________________________________________________________________>
<!__________________________________________________________________________________________________________________>
<!__________________________________________________________________________________________________________________>
<!__________________________________________________________________________________________________________________>
<!__ Lab 2: IMU ____________________________________________________________________________________________________>
            <section class="resume-section" id="Lab 2">
                <div class="resume-section-content">
                    <h2 class="mb-2.5">Lab 2: IMU</h2>
                    <p>The objective of the lab is to connect the IMU to the Artemis board and record the robot 
                        performing a stunt.
                    </p>
<!-- Lab 2 Prelab -------------------------------------------------------------------------------------------------->
                    <h2 class="mb-2.5">Prelab</h2>
                    <p>The prelab involved reading about the IMU used in the lab. The lab materials include: 
                        <li><a href="https://www.sparkfun.com/products/15443">SparkFun RedBoard Artemis Nano</a></li>
                        <li><a href="https://www.amazon.com/SUMPK-Charging-Braided-Compatible-Samsung/dp/B09Z6J21LY/ref=sr_1_4?keywords=usb%2Bc%2Bto%2Bc&qid=1636380583&qsid=147-6677549-1776715&refinements=p_n_feature_ten_browse-bin%3A23555327011&rnid=23555276011&s=pc&sr=1-4&sres=B08D9SB161%2CB08R68T84N%2CB01CZVEUIE%2CB01FM51812%2CB07VCZV3R4%2CB075V68NVR%2CB075GMKZWW%2CB093BVBRJT%2CB09BBBJ33F%2CB09C2D9Z7T%2CB012V56D2A%2CB092CYFQMP%2CB081L4V3DN%2CB07Y6ZJT1D%2CB07Y2XKPX5%2CB07VPYJV8V%2CB07THJGZ9Z%2CB08W2TP2TT%2CB0744BKDRD%2CB07THFJ1J5&srpt=ELECTRONIC_CABLE&th=1">UCB-C to USB-C Cable</a></li>
                        <li><a href="https://www.sparkfun.com/products/15335">SparkFun 9DOF IMU Sensor</a> and <a href="https://cdn.sparkfun.com/assets/7/f/e/c/d/DS-000189-ICM-20948-v1.3.pdf">IMU Datasheet</a></li>
                        <li><a href="https://force1rc.com/products/cyclone-remote-control-car-for-kids-adults">Force 1 RC Car</a></li>
                        <li><a href="https://www.amazon.com/URGENEX-Battery-Rechargeable-Quadcopter-Charger/dp/B08T9FB56F/ref=sr_1_3?keywords=lipo+battery+3.7V+850mah&qid=1639066404&sr=8-3">Li_Ion 3.7V 850mAh Battery</a></li>
                    </p>
<!-- Lab 2 Lab Tasks ----------------------------------------------------------------------------------------------->
                    <h2 class="mb-2.5">Lab Tasks</h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                        <h3 class="mb-0">Task 1: Set Up The IMU</h3> <!--------------------------------------------->
                        <h4 class="mb-0">Install SparkFun</h4>
                        <p>The SparkFun 9DOF IMU Breakout - ICM 20948 - Arduino Library was installed. 
                        </p>
                        <img width="500" height="auto" src="Lab2/IMULibrary.png"></img>
                        <hr>
                        <h4 class="mb-0">Artemis IMU Connections</h4>
                        <p>The setup for this lab is shown in the image below. 
                        </p>
                        <img width="450" height="auto" src="Lab2/Lab2Setup.jpeg"></img>
                        <hr>
                        <h4 class="mb-0">IMU Example Code and AD0_VAL</h4>
                        <p>The example code found under 
                            SparkFun 9DOF IMU Breakout - ICM 20948 - Arduino Library->Arduino->Example1_Basics 
                            was run to test if the IMU was working correctly. 
                        </p>
                        <p>Upon opening the Example1_Basics code, the AD0_VAL default was set to one. When the ADR 
                            jumper is closed the value should be set to zero. AD0_VAL corresponds to the last bit 
                            of the I2C address. My ADR jumer on the IMU was closed. For this reason, I needed to 
                            change the AD0_VAL to zero to return the accelerometer, gyroscope, magnetometer, and 
                            temperature data.
                        </p>
                        <p>While viewing the output data 
                            in the serial monitor, I moved the IMU to change the accelerometer and gyroscope data. I 
                            looked at the notated axis that was printed on the IMU and moved the IMU along the X, 
                            Y, and Z axis. I noticed that the respective X, Y, and Z serial monitor outputs for the 
                            accelerometer increased 
                            when I moved the IMU along the respective positive axis. The gyroscope data for pitch, roll, 
                            and yaw also changed when I rotated the IMU around the X, Y, and Z axis. 
                        </p>
                        <iframe width="550" height="400" src="https://youtube.com/embed/W4k1yphP308"></iframe>
                        <img width="750" height="auto" src="Lab2/Example1ArduinoPicture.png"></img>
                        <hr>
                        <h4 class="mb-0">Adding A Slow Blink</h4>
                        <p>In the Example1_Basics code, I added a slow blink at the beginning of void setup() to 
                            turn the Artemis LED on and off three times. 
                        </p>
                        <img width="300" height="auto" src="Lab2/Example1AddedBlinkArduino.png"></img>
                        <hr>
                        <iframe width="550" height="400" src="https://youtube.com/embed/f2LucKU6QsM"></iframe>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">    
                        <h3 class="mb-0">Task 2: Accelerometer</h3> <!------------------------------------------------>
                        <h4 class="mb-0">Accelerometer Equations</h4>
                        <p>The following equations for pitch (theta) and roll (phi) were found in the FastRobots-4-IMU 
                            Lecture Presentation. 
                        </p>
                        <img width="200" height="auto" src="Lab2/PitchRollEquations.png"></img>
                        <hr>
                        <h4 class="mb-0">Accelerometer Pitch and Roll at -90, 0, and 90 degrees</h4>
                        <p>These equations were used to compute pitch and roll for the accelerometer. I implemented the 
                            calculations in the Example1_Basics 
                            sketch (lines 247 - 255 below) that was used in the previous task to receive continuous data 
                            from the Artemis board and plot the results.
                        </p>
                        <img width="450" height="auto" src="Lab2/AddedExample1PitchRoll.png"></img>
                        <p>The below graphs show Pitch (data 0, green) and Roll (data 1, purple) at 0 degrees. The x-axis 
                            is time (sec) and the y-axis is degrees. 
                        </p>
                        <p>Pitch and Roll at 0 degrees:</p>
                        <img width="650" height="auto" src="Lab2/PitchAndRoll(0).png"></img>
                        <p>The below graphs show Pitch (data 0, green) at -90 and 90 degrees and the corresponding Roll 
                            (data 1, purple) outputs. The x-axis is time (sec) and the y-axis is degrees. From the graphs 
                            it can be seen that when pitch is at -90 degrees there is noise in the roll outputs.
                        </p>
                        <p>Pitch at -90 degrees:</p>
                        <img width="650" height="auto" src="Lab2/Pitch(-90).png"></img>
                        <p>Pitch at 90 degrees:</p>
                        <img width="650" height="auto" src="Lab2/Pitch(90).png"></img>
                        <p>The below graphs show Roll (data 1, purple) at -90 and 90 degrees and the corresponding Pitch 
                            (data 0, green) outputs. The x-axis is time (sec) and the y-axis is degrees. 
                        </p>
                        <p>Roll at -90 degrees:</p>
                        <img width="650" height="auto" src="Lab2/Roll(-90).png"></img>
                        <p>Roll at 90 degrees:</p>
                        <img width="650" height="auto" src="Lab2/Roll(90).png"></img>
                        <hr>
                        <h4 class="mb-0">Accuracy Analysis</h4>
                        <p>I plotted the data for pitch and roll at 0, 90, and -90 degrees in Jupyter Notebook and calculated 
                            the mean and standard deviation. 
                        </p>
                        <!-- <img width="650" height="auto" src="Lab2/AccelCode1.png"></img> -->
                        <!-- <img width="650" height="auto" src="Lab2/AccelCode2.png"></img> -->
                        <img width="650" height="auto" src="Lab2/AccelAnalysisPRPython.png"></img>
                        <p>Below are graphs. I also included a black line at 0, 90, or -90 degrees for reference. 
                            Note: The data for the graphs was collected by holding the IMU against the table using my hand. 
                            This may have resulted in some error due to the surface level or any small hand movements. In the
                            future the IMU should be calibrated when it is secured to the robot to achieve the most accurate 
                            pitch and roll data.
                        </p>
                        <img width="450" height="auto" src="Lab2/AccelPandR(0)Analysis.png"></img>
                        <img width="450" height="auto" src="Lab2/AccelAnalysisPitch(90).png"></img>
                        <img width="450" height="auto" src="Lab2/AccelAnalysisPitch(-90).png"></img>
                        <img width="450" height="auto" src="Lab2/AccelAnalysisRoll(90).png"></img>
                        <img width="450" height="auto" src="Lab2/AccelAnalysisRoll(-90).png"></img>
                        <hr>
                        <h4 class="mb-0">Fast Fourier Transform (FFT) Graphs</h4>
                        <p>The noise in the accelerometer was examined using a Fast Fourier Transform. Data for the FFT was 
                            collected as I moved the IMU. The sinusoid and the FFT graphs can be found below. There is a large 
                            spike closer to 0Hz and less noise as the frequency increases. 
                            Note: I modified the code from Stephan Wagner's Ed Discussion post to plot the FFT graphs.
                        </p>
                        <img width="450" height="auto" src="Lab2/PitchSin.png"></img>
                        <img width="450" height="auto" src="Lab2/PitchFFT.png"></img>
                        <img width="450" height="auto" src="Lab2/RollSin.png"></img>
                        <img width="450" height="auto" src="Lab2/RollFFT.png"></img> 
                        <hr>
                        <h4 class="mb-0">Low Pass Filter FFT Graphs</h4>
                        <p>From observing the above graphs, I choose a cutoff frequency of 25Hz to use for a low pass filter. 
                            Using the determined cutoff frequency, I calculated the alpha used in the low pass filter. The 
                            equations from lecture are below:
                        </p>
                        <img width="450" height="auto" src="Lab2/LPFalpha.png"></img>
                        <p>The low pass filter alpha was calculated to be 0.3698</p>
                        <p>The low pass filter was implemented in Arduino. The code to find pitch and roll for the accelerometer 
                            can be found below.
                        </p>
                        <img width="450" height="auto" src="Lab2/AccelArduino1.png"></img>
                        <img width="450" height="auto" src="Lab2/AccelArduino2.png"></img>
                        <p>The below FFT graphs show the original signal (red) and the reduction in noise after implementing a 
                            low pass filter (blue). Choosing a lower cut off frequency reduces more noise.
                        </p>
                        <img width="450" height="auto" src="Lab2/LPFPitchSin.png"></img>
                        <img width="450" height="auto" src="Lab2/LPFPitchFFT.png"></img>
                        <img width="450" height="auto" src="Lab2/LPFRollSin.png"></img>
                        <img width="450" height="auto" src="Lab2/LPFRollFFT.png"></img>
                        <p>Prior to implementing a low pass filter, there was not a significant level of noise in the IMU data 
                            due to a pre-existing internal low pass filter. The information for this can be found on page 10 of 
                            the <a href="https://www.mouser.com/datasheet/2/813/DS_000189_ICM_20948_v1_3-2489786.pdf">datasheet</a> 
                            for the IMU.
                        </p>
                        <img width="550" height="auto" src="Lab2/IMUDatasheet.png"></img>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">    
                        <h3 class="mb-0">Task 3: Gyroscope</h3> <!--------------------------------------------------->
                        <h4 class="mb-0">Gyroscope Equations</h4>
                        <p>The following equations for pitch, roll, and yaw were found in the FastRobots-4-IMU Lecture Presentation.
                        </p>
                        <img width="450" height="auto" src="Lab2/GyroEquation.png"></img>
                        <p>The gyroscope measures angular velocity. To find pitch, roll, and yaw the data collected from the IMU 
                            needs to be multiplied by a time step (dt in the below code).
                        </p>
                        <img width="450" height="auto" src="Lab2/GyroExampleCode.png"></img>
                        <hr>
                        <h4 class="mb-0">Gyroscope vs. Accelerometer Outputs</h4>
                        <p>The code above was added to Example1_Basics and plotted alongside the data for the accelerometer's pitch 
                            and roll. The gyroscope data drifts over time, but has less noise then the accelerometer data. In the 
                            below graphs the IMU was moved slightly to achieve different outputs. 
                        </p>
                        <p>Pitch for Gyroscope (Blue) and Accelerometer (Orange):</p>
                        <iframe width="550" height="400" src="https://youtube.com/embed/3sH0axPc20A"></iframe>
                        <p>Roll for Gyroscope (Blue) and Accelerometer (Teal):</p>
                        <iframe width="550" height="400" src="https://youtube.com/embed/gdAvHs-LMqg"></iframe>  
                        <p>The drift for the gyroscope can be better seen in the below graphs. The gyroscope was held in the same 
                            position as the data was collected. As time increases the measurements drift away from the starting value.
                        </p>
                        <img width="450" height="auto" src="Lab2/GDriftPitch.png"></img> 
                        <img width="450" height="auto" src="Lab2/GDriftRoll.png"></img> 
                        <img width="450" height="auto" src="Lab2/GDriftYaw.png"></img> 
                        <p>Code to plot the above graphs: 
                        </p>
                        <img width="450" height="auto" src="Lab2/GyroArray.png"></img>
                        <hr>
                        <h4 class="mb-0">Adjusting The Sampling Frequency</h4>
                        <p>Decreasing the sampling frequency resulted in a slower update to the angle measurements and more variation 
                            in the outputs between each successive measurement. The sample rate should be high to achieve the greatest 
                            level of accuracy when recording data.
                        </p>
                        <hr>
                        <h4 class="mb-0">Complimentary Filter</h4>
                        <p>Complimentary filter equation from lecture:
                        </p>
                        <img width="450" height="auto" src="Lab2/GyroCompFilterEquation.png"></img> 
                        <img width="550" height="auto" src="Lab2/GyroCompExampleCode.png"></img>
                        <p>The complimentary filter shows resistance to small vibrations as the IMU is moved during data collection. The 
                            complimentary filter reduces noise compared to the accelerometer output. Alpha is a set constant that represents 
                            how well the accelerometer output measures the correct pitch and roll data. I examined how different alpha values 
                            affected the graphs. In the below graphs alpha = 0.5
                        </p>
                        <p>Pitch for Gyroscope (Blue), Gyroscope Complimentary Filter (Orange), and Accelerometer (Teal):</p>
                        <iframe width="550" height="400" src="https://youtube.com/embed/2p3gl1_OtOk"></iframe>
                        <p>Roll for Gyroscope (Blue), Gyroscope Complimentary Filter (Orange), and Accelerometer (Teal):</p>
                        <iframe width="550" height="400" src="https://youtube.com/embed/lSK8tIzuze0"></iframe>
                        <p>Pitch for Gyroscope, Gyroscope Complimentary Filter, and Accelerometer (alpha = 0.5):</p>
                        <img width="450" height="auto" src="Lab2/GAPitch.png"></img> 
                        <img width="450" height="auto" src="Lab2/GAPitch2.png"></img> 
                        <hr>
                        <p>Roll for Gyroscope, Gyroscope Complimentary Filter, and Accelerometer (alpha = 0.5):</p>
                        <img width="450" height="auto" src="Lab2/GARoll.png"></img> 
                        <img width="450" height="auto" src="Lab2/GARoll2.png"></img> 
                        <hr>
                        <p>Additional graphs when alpha = 0.2</p>
                        <img width="450" height="auto" src="Lab2/GAPitchalpha.png"></img> 
                        <img width="450" height="auto" src="Lab2/GAPitchalpha2.png"></img> 
                        <img width="450" height="auto" src="Lab2/GARollalpha.png"></img> 
                        <img width="450" height="auto" src="Lab2/GARollalpha2.png"></img>
                        <p>Code to plot the above graphs: 
                        </p>
                        <img width="650" height="auto" src="Lab2/GyroCompArray.png"></img>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">    
                        <h3 class="mb-0">Task 4: Sample Data</h3> <!------------------------------------------------>
                        <h4 class="mb-0">Speed Of Sampling</h4>
                        <p>All of the accelerometer and gyroscope data print statements and any delays in the ble_arduino.ino file were removed 
                            in order to speed up the execution of the main loop. A case called "ACC_GYR" was created that checked if the data was 
                            ready in the main loop, and if there was data available stored it in arrays. After speeding up the loop I found that 
                            new values were sampled every 0.04s, which is a sampling frequency of 1/0.04s = 25Hz. 
                        </p>
                        <hr>
                        <h4 class="mb-0">Collect And Store Time Stamped IMU Data In Arrays</h4>
                        <p>The data is stored in arrays on the Artemis board before being sent to Jupyter Notebook. There are 7 arrays including 
                            time (1); accelerometer: x (2), y (3), z (4); gyroscope: x (5), y (6), z (7). I choose to use separate arrays because
                            in the future I can decide what data I want to send to Jupyter Notebook. The data type used to store the data is a float.
                            I choose to use a float as it is less bytes then a double, allowing for more data to be stored on the memory of the 
                            Artemis. A float is 4 bytes, resulting in one packet of data information for the 7 arrays to be 28 bytes. The Artemis has 
                            384kB of RAM. Sampling at 0.04s (25Hz) will result in data being collected for 548 seconds. 
                        </p>
                        <p>Code to find X, Y, and Z for Accelerometer and Gyroscope.</p>
                            <img width="450" height="auto" src="Lab2/endcode1.png"></img>
                            <img width="550" height="auto" src="Lab2/endcode2.png"></img>
                        <p>Code to find pitch and roll for Accelerometer; and pitch, pitch compliment, roll, roll compliment, and yaw for Gyroscope.
                        </p>
                            <img width="550" height="auto" src="Lab2/Lab2NewPart1.png"></img>
                            <img width="550" height="auto" src="Lab2/Lab2NewPart2.png"></img>
                        </p>
                        <hr>
                        <h4 class="mb-0">At Least 5 Seconds of IMU Data Sent Over Bluetooth</h4>
                        <p> I collected data for the X,Y,Z positions of the accelerometer and gyroscope as well as the pitch and roll for the 
                            accelerometer; and pitch, roll, and yaw for the gyroscope.
                        </p>
                        <img width="550" height="auto" src="Lab2/SampleData.png"></img>
                        <img width="550" height="auto" src="Lab2/Lab2NewGraph.png"></img>
                        <img width="550" height="auto" src="Lab2/Lab2NewData.png"></img>
                        <!- <img width="550" height="auto" src="Lab2/SampleDataPrint.png"></img> 
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">    
                        <h3 class="mb-0">Task 5: Stunt Recording</h3> <!-------------------------------------------->
                        <p>The robot is moved using the controller. The robot can move very quickly, but it is hard to 
                            control the speed. If the robot changes directions too quickly there is a chance that it 
                            might flip over. It is also hard to slow down the robot to a stop. When slowing down the 
                            robot, the reverse needs to be applied. This is easy to over compensate and the robot might 
                            end up traveling in reverse rather than coming to a stop. 
                        </p>
                        <iframe width="550" height="400" src="https://youtube.com/embed/rJJAcrVZHNI"></iframe>
                        </div>
                    </div>
<!-- Lab 2 References ---------------------------------------------------------------------------------------------->
                <h2 class="mb-2.5">Lab 2 References</h2>
                <p>Thank you to all of the TAs that answered my questions. I referenced the past lab reports of 
                    Liam Kain, Rafael Gottlieb, Larry Lu, Julian Prieto, and Ignacio Romo.
                </p>
        </div>
    </section>
<!__________________________________________________________________________________________________________________>
<!__________________________________________________________________________________________________________________>
<!__________________________________________________________________________________________________________________>
<!__________________________________________________________________________________________________________________>
<!__________________________________________________________________________________________________________________>
<!__ Lab 1: The Artemis Board And Bluetooth ________________________________________________________________________>
            <section class="resume-section" id="Lab 1">
                <div class="resume-section-content">
                    <h2 class="mb-5">Lab 1: The Artemis Board and Bluetooth</h2>
<!-- Lab 1 Part 1 -------------------------------------------------------------------------------------------------->
                    <h2 class="mb-5">Part 1</h2>
                    <p>Test the connection between the Artemis board and the computer. Arduino IDE was installed and 
                        a number of tasks were completed to show the functionality of the Artemis board.
                    </p>
<!-- Lab 1 Part 1 Prelab ------------------------------------------------------------------------------------------->
                    <h2 class="mb-2.5">Prelab</h2>
                    <p>Arduino IDE 2.2.1 was installed onto my computer.</p>
                    <p>Materials include:
                        <li><a href="https://www.arduino.cc/en/software">Arduino IDE</a></li>
                        <li><a href="https://www.sparkfun.com/products/15443">SparkFun RedBoard Artemis Nano</a></li>
                        <li>USB-C to USB-C cable</li>
                    </p>
                    <p><a href="https://hackaday.io/project/181686-better-serial-plotter">Better Serial Plotter</a> 
                        was installed to plot the temperature in Task 4.
                    </p>
<!-- Lab 1 Part 1 Lab Tasks ---------------------------------------------------------------------------------------->
                    <h2 class="mb-2.5">Lab Tasks</h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Tasks 1 and 2: "Example: Blink It Up"</h3>
                            <p>The instructions for 
                                <a href="https://learn.sparkfun.com/tutorials/artemis-development-with-arduino?_ga=2.30055167.1151850962.1594648676-1889762036.1574524297&_gac=1.19903818.1593457111.Cj0KCQjwoub3BRC6ARIsABGhnyahkG7hU2v-0bSiAeprvZ7c9v0XEKYdVHIIi_-J-m5YLdDBMc2P_goaAtA4EALw_wcB">Arduino Installation</a>
                                were followed to ensure proper connection between the Artemis board and the computer. 
                                The SparkFun Apollo3 Boards package was installed using the Boards Manager in Arduino 
                                IDE (shown below). 
                            </p>
                            <img width="450" height="auto" src="assets/img/BoardManagerLab1.png"></img>
                            <p>The first task involved a blinking LED on the Artemis board. Example code: 
                                File->Examples->01.Basics->Blink. A loop was implemented and used the function 
                                digitalWrite() to turn on the LED for one second and then turn off the LED for one 
                                second (shown below). 
                            </p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/RmXWC8GnBA8"></iframe>
                        </div>                        
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Task 3: Example04_Serial</h3>
                            <p>In this example serial communication between the Artemis board and the computer was tested. 
                                Example code: File->Examples->Apollo3->Example04_Serial. 
                            </p>
                            <p>Below is an image and video of the Serial Monitor showing the outputs: "Hello", 
                                "This is the serial example", "Test 1", "Test 2", and "Test 3".
                            </p>
                            <img width="650" height="auto" src="assets/img/SerialExample.png"></img>
                            <iframe width="550" height="400" src="https://youtube.com/embed/SPOZG18yV_w"></iframe>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Task 4: Example02_AnalogRead</h3>
                            <p>The temperature sensor of the Artemis board was tested. Example code:
                                File->Examples->Apollo3->Example02_AnalogRead. I covered the sensor with my hand to increase 
                                the temperature reading. At the beginning of the test the temperature is around 32.3 degrees 
                                Celsius and reaches a temperature of around 33.4 degrees Celsius (shown below).
                            </p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/mSfWqqGDKHo"></iframe>
                            <p>Another example shows various temperatures being plotted using Better Serial Plotter.
                            </p>
                            <img width="550" height="auto" src="assets/img/TempGraph.png"></img>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Task 5: Example1_MicrophoneOutput</h3>
                            <p>The Microphone Output task tests the microphone of the Artemis board. Example code: 
                                File->Examples->PDM->Example1_MicrophoneOutput. During this task I spoke into the 
                                microphone to change the frequency (image and video shown below). 
                            </p>
                            <img width="550" height="auto" src="assets/img/MicrophoneOutputArduinoPicture.png"></img>
                            <iframe width="550" height="400" src="https://youtube.com/embed/4mBy6SBxSOk"></iframe>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">5000 Level Task 1: LED and Musical A4</h3>
                            <p>The Artemis board was programmed to turn on the LED when the musical note A4 is played 
                                on a speaker (code below). I started with the Example01_MicrophoneOutput sketch, 
                                and I added if statements (lines 113-122 below). The note A4 is 440Hz 
                                <a href="https://ptolemy.berkeley.edu/eecs20/week8/scale.html#:~:text=The%20frequencies%20440Hz%20and%20880Hz,12%20notes%20in%20every%20octave.">(UC Berkeley Reference)</a>. 
                                The first if statement determines if the frequency is between 430Hz and 450Hz to account 
                                for any slight error in sound quality. If the frequency is within range an A4 statement 
                                will be displayed in the Serial Monitor and the LED on the Artemis board will turn on. 
                                The second if statement determines if the frequency is lower than 430Hz or greater than 
                                450Hz. If the frequency is lower than 430Hz or greater than 450Hz a Not A4 statement 
                                will be displayed in the Serial Monitor and the LED on the Artemis board will turn off.
                            </p>
                            <img width="550" height="auto" src="assets/img/LEDAndMusicalA4Code.png"></img>
                            <p>Image of the outputs in the serial monitor:
                            </p>
                            <img width="550" height="auto" src="assets/img/LEDAndMusicalA4Picture.png"></img>
                            <p>Video showing the LED turning on when the note A4 is played:
                            </p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/t5JuJGBvxds"></iframe>
                           <!-- <iframe width="550" height="400" src="https://youtube.com/embed/BfnU4FwXjzY"></iframe> -->
                            <p>I added to the LED and Musical A4 task by creating a musical tuner. There are eleven total 
                                if statements that determine the note being played (lines 113-168 below):
                                <li>A4       : 440Hz (range 430Hz - 450Hz)</li>
                                <li>B4 Flat  : 466Hz (range 456Hz - 476Hz)</li>
                                <li>B4       : 494Hz (range 484Hz - 504Hz)</li>
                                <li>C5       : 523Hz (range 513Hz - 533Hz)</li> 
                                <li>C5 Sharp : 554Hz (range 544Hz - 564Hz)</li> 
                                <li>D5       : 587Hz (range 577Hz - 597Hz)</li>
                                <li>D5 Sharp : 622Hz (range 612Hz - 632Hz)</li>
                                <li>E5       : 659Hz (range 649Hz - 669Hz)</li>
                                <li>F5       : 698Hz (range 688Hz - 708Hz)</li>
                                <li>F5 Sharp : 740Hz (range 730Hz - 750Hz)</li> 
                                <li>G5       : 784Hz (range 774Hz - 794Hz)</li>
                            </p>
                            <img width="550" height="auto" src="assets/img/MusicalTunerPart1.png"></img>
                            <img width="550" height="auto" src="assets/img/MusicalTunerPart2.png"></img>
                            <p>Video of various notes being played: 
                            </p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/FZQ0NdW-NL0"></iframe>
                            <p>Videos:
                                <a href="https://www.youtube.com/watch?v=buimPG01gcs">A4</a>
                                <a href="https://www.youtube.com/watch?v=QE8AMN7jsg0">B4</a>
                                <a href="https://www.youtube.com/watch?v=QJ8LUGsukzY">C5</a>
                                <a href="https://www.youtube.com/watch?v=qP9inYU8nQk">D5</a>
                                <a href="https://www.youtube.com/watch?v=Df9yjr0rBr0">E5</a>
                                <a href="https://www.youtube.com/watch?v=tGNBLJTdZvs">F5</a>
                                <a href="https://www.youtube.com/watch?v=1qx0tCQet_U">G5</a>
                            </p>
                        </div>
                    </div>
<!-- Lab 1 Part 1 Discussion --------------------------------------------------------------------------------------->
                    <h2 class="mb-2.5">Discussion: Part 1</h2>
                    <p>I tested the connection between the Artemis board and the computer. Tasks performed included 
                        turning on and off an Artemis board LED, printing serial monitor outputs, viewing temperature 
                        data in the serial monitor, testing the microphone, and creating a musical tuner. 
                    </p>
<!-- Lab 1 Part 2 -------------------------------------------------------------------------------------------------->
                    <h2 class="mb-5">Part 2</h2>
                    <p>Tested the Bluetooth communication between the computer and the Artemis board. Python in a 
                        Jupyter Notebook was used for the computer and Arduino IDE was used for the Artemis board.
                    </p>
<!-- Lab 1 Part 2 Prelab: Setup ------------------------------------------------------------------------------------>
                    <h2 class="mb-2.5">Prelab: Setup</h2>
                    <p>During the setup for the lab I already had installed Python 3. I needed to install pip by 
                        running the line "python3 -m pip install --user virtualenv" in the Command Line Interface 
                        (CLI). I created a folder called MAE 5190 Lab where I put all of the Jupyter Notebook files. 
                        I then created a virtual environment by typing "python3 -m venv FastRobots_ble" in the CLI. 
                    </p>
                    <p>The virtual environment was activated by typing "source FastRobots_ble/bin/activate" and then 
                        deactivated by typing "deactivate". 
                    </p>
                    <p>The python packages were installed by entering "pip install numpy pyyaml colorama nest_asyncio 
                        bleak jupyterlab" into the CLI.
                    </p>
                    <p>CLI entered commands:
                    </p>
                    <img width="auto" height="50" src="assets/img/Lab1PrelabPart1.png"></img>
                    <img width="auto" height="75" src="assets/img/Lab1PrelabPart2.png"></img>
                    <p>I also needed to install matplotlib to use for the 5000 level tasks. I asked a TA for help with 
                        the installation. Below is a picture of the command entered into the CLI.
                    </p>
                    <img width="auto" height="30" src="assets/img/matplotlib.png"></img>
                    <p>To import modules into the Jupyter Notebook the following lines of code were run.
                    </p>
                    <img width="550" height="auto" src="assets/img/ImportModules.png"></img>
                    <p>After uploading the provided ble_ardunio.ino file to the Artemis board the MAC address was 
                        printed in the serial monitor. The MAC address is c0:83:34:6a:b2:3c The image below shows 
                        the Arduino serial monitor with the printed MAC address.
                    </p>
                    <img width="600" height="auto" src="assets/img/Lab1PrelabPart3.png"></img>              
<!-- Lab 1 Part 2 Prelab: Codebase --------------------------------------------------------------------------------->
                    <h2 class="mb-2.5">Prelab: Codebase</h2>
                    <p>I installed the provided codebase into the project directory and copied the provided 
                        ble_python directory into the project directory. Then the Jupyter Notebook was opened by 
                        entering jupyter lab into the CLI (shown below).
                    </p>
                    <img width="auto" height="20" src="assets/img/jupyterlab.png"></img>
                    <p>To set up Bluetooth communication, the MAC address needed to be changed in the Jupyter 
                        Notebook connection.yaml file to match the advertised MAC address from the Artemis board. 
                        Then unique UUID addresses needed to be used in the connection.yaml file and Arduino IDE 
                        because some devices in the lab may have the same MAC address. Using UUIDs ensures that 
                        the computer is receiving data from the correct Artemis board. The UUIDs were generated in 
                        the Jupyter Notebook demo.ipynb file and then entered into the connection.yaml and 
                        ble_arduino.ino files. Below is a picture of the lines of code used in the demo.ipynb file 
                        to generate the UUIDs.
                    </p>
                    <img width="500" height="auto" src="assets/img/UUIDsJupyter.png"></img>
                    <p>The UUIDs were entered into the ble_arduino.ino file:</p>
                    <img width="500" height="auto" src="assets/img/UUIDsArduino.png"></img>
                    <p>The UUIDs were entered into the connection.yaml file:</p>
                    <img width="500" height="auto" src="assets/img/UUIDsPython.png"></img>
                    <p>To connect to the Artemis the following lines were run in the Jupyter Notebook.</p>
                    <img width="650" height="auto" src="assets/img/ConnectionPython.png"></img>
                    <p>Several command types needed to be defined to complete the tasks outlined in the next section. 
                        Added commands include ECHO, GET_TIME_MILLIS, GET_TIME_MILLIS_LOOP, SEND_TIME_DATA, 
                        and GET_TEMP_READINGS.
                    </p>
                    <p>Command types defined in Arduino IDE:</p>
                    <img width="250" height="auto" src="assets/img/CommandTypesArduino.png"></img>
                    <p>Command types defined in Jupyter Notebook:</p>
                    <img width="250" height="auto" src="assets/img/CmdTypesPython.png"></img>
<!-- Lab 1 Part 2 Lab Tasks ---------------------------------------------------------------------------------------->
                    <h2 class="mb-2.5">Lab Tasks</h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Task 1: ECHO Command</h3>
                            <p>The first task was to send an ECHO command of a string value to the Artemis board and 
                                receive an augmented string on the host computer. This task tested the communication 
                                between the Artemis board and the computer. 
                            </p>
                            <p>The image below shows the Arduino IDE code.
                            </p>
                            <img width="550" height="auto" src="assets/img/EchoArduino.png"></img>
                            <p>Jupyter Notebook code to send the ECHO command and receive the augmented string from 
                                the Artemis board:
                            </p>
                            <img width="650" height="auto" src="assets/img/EchoPython.png"></img>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Task 2: GET_TIME_MILLIS</h3>
                            <p>The next task adds another command to the Jupyter Notebook for the Artemis board to 
                                reply with a string of the current time. 
                            </p>
                            <p>The image below shows the Arduino IDE code.
                            </p>
                            <img width="500" height="auto" src="assets/img/GetTimeMillisArduino.png"></img>
                            <p>Jupyter Notebook code to send the GET_TIME_MILLIS command and receive the string 
                                with the current time:
                            </p>
                            <img width="650" height="auto" src="assets/img/GetTimeMillisPython.png"></img>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Task 3: Notification Handler</h3>
                            <p>A notification handler was created in the Python Jupyter Notebook to receive a 
                                string value from the Artemis board. The GET_TIME_MILLIS command was used to 
                                get the time after starting the notification handler.
                            </p>
                            <p>The image below is the notification handler and the GET_TIME_MILLIS command in 
                                the Jupyter Notebook.
                            </p>
                            <img width="650" height="auto" src="assets/img/NotificationHandlerPython.png"></img>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Task 4: Current Time Loop</h3>
                            <p>A loop was implemented to  get the current time in milliseconds from the Artemis 
                                board and send the information to the computer. The time information is received 
                                and processed by the notification handler. 
                            </p>
                            <p>To find the data transfer rate the length of the data was computed by assembling the 
                                individual outputs into an array in the Jupyter Notebook. The number of strings in 
                                each element of the array is 9, and the number of elements in the array is 748. The 
                                time difference of the final (40.428s) and starting time (35.434s) was found to be 
                                4.994 seconds. The data transfer rate is 
                                (748*9)bytes/4.994seconds = 1348.018 bytes/second
                            </p>
                            <p>The image below shows the Arduino IDE code for case GET_TIME_MILLIS_LOOP.
                            </p>
                            <img width="500" height="auto" src="assets/img/GetTimeMillisLoopArduino.png"></img>
                            <p>The image below shows the Jupyter Notebook command and some of the time outputs.
                            </p>
                            <img width="650" height="auto" src="assets/img/GetTimeMillisLoopPython.png"></img>
                            <p>The following statements in Jupyter Notebook printed the timeSarray and the length 
                                of the array that was used to compute the data transfer rate.
                            </p>
                            <img width="650" height="auto" src="assets/img/PrintStatements.png"></img>
                            <p>The video below shows all of the time outputs.
                            </p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/PBhUSLNY_qY"></iframe>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Task 5: SEND_TIME_DATA</h3>
                            <p>A globally defined array to store time stamps was implemented. Inside of the for loop 
                                each time stamp is put inside of the timearray. The data is then sent as an array 
                                to the computer using Jupyter Notebook. 
                            </p>
                            <p>To find the data transfer rate the length of the data was computed by assembling the 
                                individual outputs into an array in the Jupyter Notebook. The number of strings in 
                                each element of the array is 9, and the number of elements in the array is 2748. 
                                The time difference of the final (49.730s) and starting time (49.685s) was found to 
                                be 0.045 seconds. The data transfer rate is 
                                (2748*9)bytes/0.045seconds = 549600 bytes/second
                            </p>
                            <p>The image below shows the Arduino IDE code.
                            </p>
                            <img width="500" height="auto" src="assets/img/SendTimeDataArduino.png"></img>
                            <p>The image below shows the Jupyter Notebook command and some of the time outputs
                                in the array.
                            </p>
                            <img width="550" height="auto" src="assets/img/SendTimeDataPython.png"></img>
                            <p>The following statements in Jupyter Notebook printed the timeSarray and the length 
                                of the array that was used to compute the data transfer rate.
                            </p>
                            <img width="650" height="auto" src="assets/img/PrintStatements.png"></img>
                            <p>The video below shows all of the times in the array.
                            </p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/93hRV7vIr8Y"></iframe>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Task 6: GET_TEMP_READINGS</h3>
                            <p>A second array was added to store temperature readings from the Artemis board. The 
                                temperature array is the same size as the time array. The time and temperature 
                                readings were taken at the same time. The data is sent as an array to the computer 
                                using Jupyter Notebook. 
                            </p>
                            <p>The image below shows the Arduino IDE code. 
                            </p>
                            <img width="550" height="auto" src="assets/img/GetTempReadingsArduino.png"></img>
                            <p>The image below shows the Jupyter Notebook command and some of the time and temperature
                                outputs in the array.
                            </p>
                            <img width="650" height="auto" src="assets/img/GetTempReadingsPython.png"></img>
                            <p>The video below shows all of the times and temperatures in the array. 
                            </p>
                            <iframe width="550" height="400" src="https://youtube.com/embed/ATMvf5GT68A"></iframe>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Task 7: Discussion For Task 4 and Task 5</h3>
                            <p>The method used in Task 4 involved sending the current time from the Artemis board to 
                                the computer. Each time was sent as an individual piece of data. The method used in 
                                Task 5 involved creating an array of times that was stored on the memory of the 
                                Artemis board and then sent to the computer to display the collected data. 
                            </p>
                            <p>The data transfer rate of the array method used in Task 5 (549600 bytes/second) is 
                                faster than the data transfer rate when sending individual pieces of data in Task 4 
                                (1348.018 bytes/second).
                            </p>
                            <p>An advantage of sending data individually as in Task 4 is that less memory on the 
                                Artemis board is being used, but the disadvantage is a slower data transfer rate. 
                                An advantage of sending data as an array as in Task 5 is that there is a faster data 
                                transfer rate, but a disadvantage is that more memory is being used on the Artemis 
                                to store the array.
                            </p>
                            <p>The Artemis board has a maximum storage of 384 kB of RAM. If 16 bit values at 150 Hz 
                                were sampled every 5 seconds, 256 values would be stored before running out of memory 
                                on the Artemis board. The calculations can be found below.
                            </p>
                            <img width="500" height="auto" src="assets/img/math.png"></img>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">5000 Level Task 1: Effective Data Rate And Overhead</h3>
                            <p>I sent a message from the computer and received a reply from the Artemis board. The data 
                                rate for 5, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, and 120 bytes was tested. The 
                                data rate for 5 bytes is 132.722 bytes/s and the data rate for 120 bytes is 2003.210 
                                bytes/s. The plotted graph shows that as the number of bytes sent to the Artemis board 
                                increases, the data rate increases. Below are pictures of the Jupyter Notebook code, the 
                                graph, and the printed statements.
                            </p>
                            <img width="550" height="auto" src="assets/img/DataTranferNHPython.png"></img>
                            <img width="550" height="auto" src="assets/img/DataTransferPython.png"></img>
                            <img width="550" height="auto" src="assets/img/DataTransferGraph.png"></img>
                            <img width="650" height="auto" src="assets/img/DTPart1.png"></img>
                            <img width="650" height="auto" src="assets/img/DTPart2.png"></img>
                            <img width="650" height="auto" src="assets/img/DTPart3.png"></img>
                            <p>Additional graphs:</p>
                            <img width="550" height="auto" src="assets/img/DTGraph2.png"></img>
                            <img width="550" height="auto" src="assets/img/DTGraph3.png"></img>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">5000 Level Task 2: Reliability</h3>
                            <p>I tested the reliability of sending data at a higher rate from the robot to the 
                                computer. To determine the reliability of the data I ran the GET_TEMP_READINGS 
                                command and compared the outputs printed in the Jupyter Notebook and the Arduino 
                                IDE Serial Monitor. 
                            </p>
                            <img width="650" height="auto" src="assets/img/ReliabilityArduino.png"></img>
                            <p>Outputs in the Jupyter Notebook (left) and the Arduino Serial Monitor (right):
                            </p>
                            <img width="650" height="auto" src="assets/img/ReliabilityArduinoAndPython.png"></img>
                            <p>After looking at the outputs, the time and temperature readings on the computer are 
                                the same as the Artemis board and no data is missed. To confirm I copied and pasted 
                                the data from each window into Matlab variables titled time1 and temp1 for the 
                                Jupyter Notebook data, and time2 and temp2 for the Artemis data. I wrote a script to 
                                compare the corresponding time and temperature data and record how many data points 
                                are the same and how many are different. If there is a data point in the Jupyter 
                                Notebook that does not correspond to the Artemis board, or vice versa, an error 
                                message is displayed. The output variables in the workspace show that all data points 
                                are the same. The reliability is 100%.
                            </p>
                            <img width="450" height="auto" src="assets/img/Lab1MatlabPart1.png"></img>
                            <img width="450" height="auto" src="assets/img/Lab1MatlabPart2.png"></img>
                        </div>
                    </div>
<!-- Lab 1 Part 2 Discussion --------------------------------------------------------------------------------------->
                    <h2 class="mb-2.5">Discussion: Part 2</h2>
                    <p>I learned how to use Bluetooth communication and UUIDs, between the Artemis board and 
                        computer. I did not experience any significant problems connecting to Bluetooth. 
                    </p>
<!-- Lab 1 References ---------------------------------------------------------------------------------------------->
                    <h2 class="mb-2.5">Lab 1 References</h2>
                    <p>Thank you to all of the TAs that answered my questions. I referenced the past lab reports of 
                        Liam Kain, Rafael Gottlieb, Larry Lu, Julian Prieto, and Ignacio Romo.
                    </p>
                </div>
            </section>
            <hr class="m-0" />
<!__ END OF DOCUMENT _______________________________________________________________________________________________>
        </div>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
    </body>
</html>
